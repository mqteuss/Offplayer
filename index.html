<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player de Música Offline</title>
    
    <!-- 
    ============================================================================
    PLAYER DE MÚSICA OFFLINE v1.0
    ============================================================================
    
    INSTRUÇÕES DE USO:
    1. Salve este arquivo como "player.html" (ou qualquer outro nome .html).
    2. Abra o arquivo salvo no seu navegador (Chrome, Edge, Firefox são recomendados).
    3. Para adicionar músicas:
       - Clique no botão "Adicionar Músicas" e selecione uma pasta com seus arquivos de áudio.
       - Ou arraste e solte arquivos de áudio diretamente na janela do player.
    4. As músicas serão salvas no seu navegador e estarão disponíveis mesmo que você
       recarregue a página ou a abra offline mais tarde.
    5. Use o botão "Limpar Biblioteca" para apagar todas as músicas salvas.

    NOTAS DE IMPLEMENTAÇÃO E COMPATIBILIDADE:
    - Armazenamento: Utiliza IndexedDB para salvar os arquivos de música no navegador.
      O limite de armazenamento varia conforme o navegador e o espaço livre no disco.
    - Seleção de Pastas: A funcionalidade de selecionar uma pasta inteira (`webkitdirectory`)
      é melhor suportada em navegadores baseados em Chromium (Chrome, Edge). No Firefox
      e outros, o seletor de arquivos permitirá a seleção múltipla de arquivos como fallback.
    - Offline: Após o primeiro carregamento, o player pode ser usado offline. Para uma
      experiência de app mais robusta, um Service Worker básico está incluído, mas
      funciona melhor quando o arquivo é servido por um servidor local (ex: `npx serve`).
    - Metadados: Usa a biblioteca `jsmediatags` (via CDN) para tentar ler metadados
      (título, artista, capa) dos arquivos. Se não encontrar, exibe o nome do arquivo.
    - Formatos: Suporta nativamente os formatos que o navegador suporta (geralmente
      MP3, M4A, OGG, WAV, FLAC). Arquivos inválidos são ignorados.

    ============================================================================
    -->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>

    <style>
        :root {
            --bg-color: #121212;
            --card-bg-color: rgba(30, 30, 30, 0.6);
            --primary-text-color: #ffffff;
            --secondary-text-color: #b3b3b3;
            --accent-color-1: #3b82f6;
            --accent-color-2: #8b5cf6;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --font-family: 'Inter', sans-serif;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            background-image: linear-gradient(160deg, var(--bg-color) 0%, #291a3e 100%);
            color: var(--primary-text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .app-container {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            max-height: 800px;
            display: flex;
            gap: 1.5rem;
            background: transparent;
        }

        /* --- Seção de Instruções e Player --- */
        .main-content {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: 100%;
        }

        .instructions {
            background: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1rem 1.5rem;
            font-size: 0.85rem;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--secondary-text-color);
        }
        .instructions h2 {
            color: var(--primary-text-color);
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        .instructions ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }

        .player-card {
            flex-grow: 1;
            background: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 24px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            text-align: center;
            transition: all 0.3s ease;
        }

        #album-art {
            width: 180px;
            height: 180px;
            border-radius: 16px;
            background-color: rgba(255, 255, 255, 0.05);
            margin-bottom: 1.5rem;
            object-fit: cover;
            box-shadow: 0 4px 15px var(--shadow-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #album-art-img {
            width: 100%;
            height: 100%;
            border-radius: 16px;
            object-fit: cover;
        }

        #album-art-placeholder svg {
            width: 60px;
            height: 60px;
            color: var(--secondary-text-color);
        }

        #track-info {
            margin-bottom: 1rem;
        }
        #track-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }
        #track-artist {
            font-size: 1rem;
            color: var(--secondary-text-color);
        }

        #visualizer {
            width: 100%;
            height: 60px;
            margin-bottom: 1rem;
        }

        .controls-wrapper {
            width: 100%;
        }

        .time-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            margin-bottom: 0.25rem;
        }

        #progress-bar {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        #progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-text-color);
            border-radius: 50%;
            cursor: pointer;
            transform: scale(0);
            transition: transform 0.2s ease;
        }
        #progress-bar:hover::-webkit-slider-thumb {
            transform: scale(1);
        }
        #progress-bar::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--primary-text-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transform: scale(0);
            transition: transform 0.2s ease;
        }
        #progress-bar:hover::-moz-range-thumb {
            transform: scale(1);
        }

        .player-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .control-btn {
            background: transparent;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .control-btn:hover {
            color: var(--primary-text-color);
            background-color: rgba(255, 255, 255, 0.1);
        }
        .control-btn.active {
            color: var(--accent-color-1);
        }
        .control-btn svg {
            width: 20px;
            height: 20px;
        }
        
        #play-pause-btn {
            background: linear-gradient(135deg, var(--accent-color-1), var(--accent-color-2));
            color: var(--primary-text-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
        }
        #play-pause-btn svg {
            width: 30px;
            height: 30px;
        }
        #play-pause-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }
        
        .volume-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 150px;
            margin: 0 auto;
        }
        
        #volume-slider {
             -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary-text-color);
            border-radius: 50%;
            cursor: pointer;
        }
        #volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--primary-text-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        #mute-btn svg {
            width: 18px;
            height: 18px;
        }

        /* --- Playlist --- */
        .playlist-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 24px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            height: 100%;
        }

        .playlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-shrink: 0;
        }
        .playlist-header h2 {
            font-size: 1.25rem;
        }

        .header-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--primary-text-color);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #clear-library-btn {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.5);
        }
        #clear-library-btn:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        #playlist {
            list-style: none;
            overflow-y: auto;
            flex-grow: 1;
        }
        #playlist::-webkit-scrollbar {
            width: 6px;
        }
        #playlist::-webkit-scrollbar-track {
            background: transparent;
        }
        #playlist::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: grab;
            transition: background-color 0.2s ease;
            user-select: none;
        }
        .playlist-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .playlist-item.playing {
            background-color: rgba(59, 130, 246, 0.2);
        }
        .playlist-item.ghost {
            opacity: 0.4;
        }

        .playlist-item-art {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            margin-right: 1rem;
            object-fit: cover;
            background-color: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .playlist-item-art svg {
            width: 20px;
            height: 20px;
            color: var(--secondary-text-color);
        }
        
        .playlist-item-info {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .playlist-item-title {
            font-weight: 500;
            text-overflow: ellipsis;
            overflow: hidden;
        }
        .playlist-item-artist {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            text-overflow: ellipsis;
            overflow: hidden;
        }
        .playlist-item-duration {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            margin-left: 1rem;
        }
        .remove-track-btn {
            background: transparent;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
            padding: 0.25rem;
        }
        .playlist-item:hover .remove-track-btn {
            opacity: 1;
        }
        .remove-track-btn:hover {
            color: #ef4444;
        }
        .remove-track-btn svg {
            width: 16px;
            height: 16px;
        }

        #file-input { display: none; }

        /* --- Drag & Drop Overlay --- */
        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            border: 3px dashed var(--accent-color-1);
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: var(--primary-text-color);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 9999;
        }
        .drag-overlay.visible {
            opacity: 1;
        }

        /* --- Toast Notification --- */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--card-bg-color);
            color: var(--primary-text-color);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px var(--shadow-color);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, bottom 0.3s;
            z-index: 10000;
            font-size: 0.9rem;
        }
        
        #toast.show {
            opacity: 1;
            visibility: visible;
            bottom: 30px;
        }

        /* --- Responsividade --- */
        @media (max-width: 1024px) {
            body {
                padding: 0;
                align-items: flex-start;
            }
            .app-container {
                flex-direction: column;
                height: auto;
                max-height: none;
                gap: 1rem;
                padding: 1rem;
            }
            .main-content {
                gap: 1rem;
            }
            .playlist-container {
                height: 300px; /* Altura fixa para a playlist em telas menores */
            }
            #album-art {
                width: 150px;
                height: 150px;
            }
            #track-title {
                font-size: 1.25rem;
            }
        }
        @media (max-width: 768px) {
            .app-container {
                padding: 0.5rem;
            }
            .player-card {
                padding: 1.5rem;
            }
            .playlist-container {
                padding: 1rem;
            }
             #album-art {
                width: 120px;
                height: 120px;
            }
             .player-controls {
                 gap: 1rem;
             }
             #play-pause-btn {
                 width: 50px;
                 height: 50px;
             }
             #play-pause-btn svg {
                 width: 25px;
                 height: 25px;
             }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Coluna Principal (Player) -->
        <div class="main-content">
            <header class="instructions">
                <h2>Bem-vindo ao seu Player de Música Offline!</h2>
                <ul>
                    <li><strong>Adicione músicas:</strong> Clique em "Adicionar" ou arraste arquivos para a janela.</li>
                    <li><strong>Offline:</strong> Suas músicas ficam salvas para a próxima vez que abrir este arquivo.</li>
                </ul>
            </header>
            
            <main class="player-card">
                <div id="album-art">
                     <img id="album-art-img" src="" alt="Capa do Álbum" style="display: none;">
                     <div id="album-art-placeholder">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
                     </div>
                </div>
                
                <div id="track-info">
                    <h1 id="track-title">Nenhuma música tocando</h1>
                    <p id="track-artist">Adicione músicas para começar</p>
                </div>

                <canvas id="visualizer"></canvas>

                <div class="controls-wrapper">
                    <div class="time-info">
                        <span id="current-time">00:00</span>
                        <span id="total-duration">00:00</span>
                    </div>
                    <input type="range" id="progress-bar" value="0" step="0.1" max="100">

                    <div class="player-controls">
                        <button class="control-btn" id="shuffle-btn" aria-label="Embaralhar">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="16 16 21 16 21 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="11" y2="11"/></svg>
                        </button>
                        <button class="control-btn" id="prev-btn" aria-label="Faixa Anterior">
                           <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" y1="19" x2="5" y2="5"/></svg>
                        </button>
                        <button class="control-btn" id="play-pause-btn" aria-label="Tocar">
                            <!-- Ícone de Play -->
                            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                            <!-- Ícone de Pause -->
                            <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                        </button>
                        <button class="control-btn" id="next-btn" aria-label="Próxima Faixa">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg>
                        </button>
                        <button class="control-btn" id="loop-btn" aria-label="Repetir">
                            <!-- Ícone Loop All -->
                             <svg id="loop-all-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2l4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="M7 22l-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></svg>
                             <!-- Ícone Loop One -->
                             <svg id="loop-one-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2l4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="M7 22l-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/><path d="M11 10h1v4"/></svg>
                        </button>
                    </div>

                    <div class="volume-controls">
                         <button class="control-btn" id="mute-btn" aria-label="Mudo">
                            <!-- Ícone Volume Alto -->
                            <svg id="volume-high-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                            <!-- Ícone Volume Mudo -->
                            <svg id="volume-mute-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
                        </button>
                        <input type="range" id="volume-slider" value="1" step="0.01" max="1">
                    </div>
                </div>
            </main>
        </div>

        <!-- Coluna da Playlist -->
        <aside class="playlist-container">
            <header class="playlist-header">
                <h2>Playlist</h2>
                <div class="header-buttons">
                    <button id="add-music-btn" class="btn">Adicionar</button>
                    <button id="clear-library-btn" class="btn">Limpar Biblioteca</button>
                </div>
            </header>
            <ol id="playlist"></ol>
        </aside>
    </div>

    <!-- Elementos ocultos e overlays -->
    <audio id="audio-player"></audio>
    <input type="file" id="file-input" multiple webkitdirectory>
    <div class="drag-overlay">
        Solte os arquivos de áudio aqui
    </div>
    <div id="toast"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- Seletores de DOM ---
    const dom = {
        audioPlayer: document.getElementById('audio-player'),
        playPauseBtn: document.getElementById('play-pause-btn'),
        playIcon: document.getElementById('play-icon'),
        pauseIcon: document.getElementById('pause-icon'),
        prevBtn: document.getElementById('prev-btn'),
        nextBtn: document.getElementById('next-btn'),
        progressBar: document.getElementById('progress-bar'),
        currentTimeEl: document.getElementById('current-time'),
        totalDurationEl: document.getElementById('total-duration'),
        volumeSlider: document.getElementById('volume-slider'),
        muteBtn: document.getElementById('mute-btn'),
        volumeHighIcon: document.getElementById('volume-high-icon'),
        volumeMuteIcon: document.getElementById('volume-mute-icon'),
        loopBtn: document.getElementById('loop-btn'),
        loopAllIcon: document.getElementById('loop-all-icon'),
        loopOneIcon: document.getElementById('loop-one-icon'),
        shuffleBtn: document.getElementById('shuffle-btn'),
        playlistEl: document.getElementById('playlist'),
        addMusicBtn: document.getElementById('add-music-btn'),
        fileInput: document.getElementById('file-input'),
        clearLibraryBtn: document.getElementById('clear-library-btn'),
        trackTitleEl: document.getElementById('track-title'),
        trackArtistEl: document.getElementById('track-artist'),
        albumArtImg: document.getElementById('album-art-img'),
        albumArtPlaceholder: document.getElementById('album-art-placeholder'),
        dragOverlay: document.querySelector('.drag-overlay'),
        visualizerCanvas: document.getElementById('visualizer'),
        toast: document.getElementById('toast'),
    };
    
    // --- Estado da Aplicação ---
    let state = {
        playlist: [],
        originalPlaylist: [],
        currentIndex: -1,
        isPlaying: false,
        isShuffled: false,
        loopMode: 'none', // 'none', 'one', 'all'
        db: null,
        isSeeking: false,
        draggedItem: null
    };

    // --- Web Audio API para o Visualizador ---
    let audioContext, analyser, source, dataArray;
    let visualizerInitialized = false;

    function initVisualizer() {
        if (visualizerInitialized) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            source = audioContext.createMediaElementSource(dom.audioPlayer);
            
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            visualizerInitialized = true;
            drawVisualizer();
        } catch(e) {
            console.error("Web Audio API não é suportada neste navegador.", e);
            dom.visualizerCanvas.style.display = 'none';
        }
    }
    
    const canvasCtx = dom.visualizerCanvas.getContext('2d');
    function drawVisualizer() {
        requestAnimationFrame(drawVisualizer);
        if (!visualizerInitialized || !state.isPlaying) {
            canvasCtx.clearRect(0, 0, dom.visualizerCanvas.width, dom.visualizerCanvas.height);
            return;
        }

        analyser.getByteFrequencyData(dataArray);

        canvasCtx.clearRect(0, 0, dom.visualizerCanvas.width, dom.visualizerCanvas.height);
        
        const barWidth = (dom.visualizerCanvas.width / dataArray.length) * 1.5;
        let x = 0;
        const gradient = canvasCtx.createLinearGradient(0, 0, dom.visualizerCanvas.width, 0);
        gradient.addColorStop(0, 'rgba(59, 130, 246, 0.8)');
        gradient.addColorStop(1, 'rgba(139, 92, 246, 0.8)');

        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 2.5;
            canvasCtx.fillStyle = gradient;
            canvasCtx.fillRect(x, dom.visualizerCanvas.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }
    window.addEventListener('resize', () => {
        dom.visualizerCanvas.width = dom.visualizerCanvas.clientWidth;
        dom.visualizerCanvas.height = dom.visualizerCanvas.clientHeight;
    });
    dom.visualizerCanvas.width = dom.visualizerCanvas.clientWidth;
    dom.visualizerCanvas.height = dom.visualizerCanvas.clientHeight;


    // --- IndexedDB ---
    const DB_NAME = 'OfflineMusicPlayerDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'tracks';

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = (event) => reject("Erro ao abrir o banco de dados.");

            request.onsuccess = (event) => {
                state.db = event.target.result;
                resolve(state.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                }
            };
        });
    }
    
    function saveTrackToDB(track) {
        return new Promise((resolve, reject) => {
            if (!state.db) reject("Banco de dados não inicializado.");
            const transaction = state.db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.add(track);
            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject("Erro ao salvar a faixa.");
        });
    }

    function getAllTracksFromDB() {
        return new Promise((resolve, reject) => {
            if (!state.db) reject("Banco de dados não inicializado.");
            const transaction = state.db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject("Erro ao buscar as faixas.");
        });
    }
    
    function deleteTrackFromDB(id) {
         return new Promise((resolve, reject) => {
            if (!state.db) reject("Banco de dados não inicializado.");
            const transaction = state.db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = () => reject("Erro ao apagar a faixa.");
        });
    }

    function clearDB() {
        return new Promise((resolve, reject) => {
            if (!state.db) reject("Banco de dados não inicializado.");
            const transaction = state.db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject("Erro ao limpar o banco de dados.");
        });
    }

    // --- Lógica do Player ---
    function playTrack(index) {
        if (index < 0 || index >= state.playlist.length) return;
        
        if (!visualizerInitialized) {
            initVisualizer();
        }
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }

        state.currentIndex = index;
        const track = state.playlist[index];
        const url = URL.createObjectURL(track.file);
        dom.audioPlayer.src = url;
        dom.audioPlayer.play();
        state.isPlaying = true;
        updateUI();
    }
    
    function togglePlayPause() {
        if (state.currentIndex === -1 && state.playlist.length > 0) {
            playTrack(0);
            return;
        }

        if (dom.audioPlayer.paused) {
            dom.audioPlayer.play();
            state.isPlaying = true;
        } else {
            dom.audioPlayer.pause();
            state.isPlaying = false;
        }
        updateUI();
    }
    
    function playNext() {
        let newIndex = state.currentIndex + 1;
        if (newIndex >= state.playlist.length) {
            if (state.loopMode === 'all') {
                newIndex = 0;
            } else {
                state.isPlaying = false;
                updateUI();
                return;
            }
        }
        playTrack(newIndex);
    }
    
    function playPrev() {
        let newIndex = state.currentIndex - 1;
        if (newIndex < 0) {
            newIndex = state.playlist.length - 1;
        }
        playTrack(newIndex);
    }
    
    function handleTrackEnd() {
        if (state.loopMode === 'one') {
            playTrack(state.currentIndex);
        } else {
            playNext();
        }
    }
    
    function updateProgress() {
        if(state.isSeeking) return;
        const { duration, currentTime } = dom.audioPlayer;
        if (duration) {
            dom.progressBar.value = (currentTime / duration) * 100;
            dom.currentTimeEl.textContent = formatTime(currentTime);
        }
    }

    function seek(e) {
        const { duration } = dom.audioPlayer;
        if (duration) {
            const seekTime = (e.target.value / 100) * duration;
            dom.audioPlayer.currentTime = seekTime;
        }
    }
    
    function setVolume() {
        dom.audioPlayer.volume = dom.volumeSlider.value;
        dom.audioPlayer.muted = dom.volumeSlider.value == 0;
        updateVolumeIcon();
    }

    function toggleMute() {
        dom.audioPlayer.muted = !dom.audioPlayer.muted;
        if (dom.audioPlayer.muted) {
            dom.volumeSlider.value = 0;
        } else {
            dom.volumeSlider.value = dom.audioPlayer.volume > 0 ? dom.audioPlayer.volume : 0.5;
            dom.audioPlayer.volume = dom.volumeSlider.value;
        }
        updateVolumeIcon();
    }

    function toggleLoop() {
        const modes = ['none', 'all', 'one'];
        const currentModeIndex = modes.indexOf(state.loopMode);
        state.loopMode = modes[(currentModeIndex + 1) % modes.length];
        updateLoopIcon();
        showToast(`Repetição: ${state.loopMode === 'none' ? 'Desligada' : state.loopMode === 'all' ? 'Playlist' : 'Faixa Atual'}`);
    }

    function toggleShuffle() {
        state.isShuffled = !state.isShuffled;
        dom.shuffleBtn.classList.toggle('active', state.isShuffled);

        if (state.isShuffled) {
            const currentTrack = state.playlist[state.currentIndex];
            state.originalPlaylist = [...state.playlist];
            // Embaralhar mantendo a faixa atual no início
            const shuffled = state.playlist.filter((_, i) => i !== state.currentIndex)
                                          .sort(() => Math.random() - 0.5);
            state.playlist = [currentTrack, ...shuffled];
            state.currentIndex = 0;
        } else {
            const currentTrack = state.playlist[state.currentIndex];
            state.playlist = [...state.originalPlaylist];
            state.currentIndex = state.playlist.findIndex(track => track.id === currentTrack.id);
        }
        renderPlaylist();
        showToast(`Embaralhar: ${state.isShuffled ? 'Ativado' : 'Desativado'}`);
    }

    // --- Lógica de Arquivos e Playlist ---
    async function handleFiles(files) {
        const supportedTypes = ['audio/mpeg', 'audio/mp4', 'audio/ogg', 'audio/wav', 'audio/flac', 'audio/x-m4a'];
        let addedCount = 0;
        for (const file of files) {
            if (supportedTypes.includes(file.type)) {
                try {
                    const metadata = await readMetadata(file);
                    const newTrack = {
                        file: file,
                        title: metadata.title || file.name.replace(/\.[^/.]+$/, ""),
                        artist: metadata.artist || "Artista Desconhecido",
                        album: metadata.album || "Álbum Desconhecido",
                        picture: metadata.picture,
                        duration: 0 // Será atualizado depois
                    };
                    const id = await saveTrackToDB(newTrack);
                    newTrack.id = id;
                    state.playlist.push(newTrack);
                    addedCount++;
                } catch(err) {
                    console.error("Erro ao processar arquivo:", file.name, err);
                }
            }
        }
        renderPlaylist();
        if (addedCount > 0) showToast(`${addedCount} música(s) adicionada(s).`);
    }

    function readMetadata(file) {
        return new Promise((resolve, reject) => {
            window.jsmediatags.read(file, {
                onSuccess: (tag) => {
                    const { title, artist, album, picture } = tag.tags;
                    let imageSrc = null;
                    if (picture) {
                        const base64String = btoa(String.fromCharCode.apply(null, picture.data));
                        imageSrc = `data:${picture.format};base64,${base64String}`;
                    }
                    resolve({ title, artist, album, picture: imageSrc });
                },
                onError: (error) => {
                    // Mesmo com erro, resolvemos com dados vazios para usar o nome do arquivo
                    resolve({});
                }
            });
        });
    }
    
    async function removeTrack(index, id) {
        try {
            await deleteTrackFromDB(id);
            state.playlist.splice(index, 1);
            if(state.currentIndex === index) {
                if(state.playlist.length > 0) {
                    playNext();
                } else {
                    // Reseta o player
                    state.currentIndex = -1;
                    dom.audioPlayer.src = '';
                    updateUI();
                }
            } else if(state.currentIndex > index) {
                state.currentIndex--;
            }
            renderPlaylist();
            showToast("Música removida.");
        } catch(err) {
            showToast("Erro ao remover música.");
            console.error(err);
        }
    }
    
    async function clearLibrary() {
        if (!confirm("Tem certeza que deseja apagar todas as músicas da sua biblioteca? Esta ação não pode ser desfeita.")) {
            return;
        }
        try {
            await clearDB();
            state.playlist = [];
            state.currentIndex = -1;
            state.isPlaying = false;
            dom.audioPlayer.src = '';
            dom.audioPlayer.pause();
            renderPlaylist();
            updateUI();
            showToast("Biblioteca limpa.");
        } catch(err) {
            showToast("Erro ao limpar a biblioteca.");
            console.error(err);
        }
    }
    
    // --- Atualização da UI ---
    function renderPlaylist() {
        dom.playlistEl.innerHTML = '';
        if (state.playlist.length === 0) {
            dom.playlistEl.innerHTML = '<li style="text-align: center; color: var(--secondary-text-color); padding: 2rem 0;">Sua playlist está vazia.</li>';
        }
        
        state.playlist.forEach((track, index) => {
            const li = document.createElement('li');
            li.className = 'playlist-item';
            li.dataset.index = index;
            li.draggable = true;
            if (index === state.currentIndex) {
                li.classList.add('playing');
            }
            
            const artDiv = document.createElement('div');
            artDiv.className = 'playlist-item-art';
            if(track.picture) {
                const img = document.createElement('img');
                img.src = track.picture;
                img.alt = track.album;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                artDiv.appendChild(img);
            } else {
                artDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>`;
            }

            li.innerHTML = `
                <div class="playlist-item-info">
                    <div class="playlist-item-title">${track.title}</div>
                    <div class="playlist-item-artist">${track.artist}</div>
                </div>
                <span class="playlist-item-duration">${track.duration ? formatTime(track.duration) : '--:--'}</span>
                <button class="remove-track-btn" aria-label="Remover faixa">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            `;
            li.prepend(artDiv);

            li.addEventListener('click', (e) => {
                if (e.target.closest('.remove-track-btn')) {
                    removeTrack(index, track.id);
                } else {
                    playTrack(index);
                }
            });
            dom.playlistEl.appendChild(li);
        });
        
        // Adicionar eventos de drag and drop na playlist
        addPlaylistDragEvents();
    }
    
    function addPlaylistDragEvents() {
        const items = dom.playlistEl.querySelectorAll('.playlist-item');
        items.forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
            item.addEventListener('dragend', handleDragEnd);
        });
    }
    
    function updateUI() {
        // Botão Play/Pause
        if (state.isPlaying) {
            dom.playIcon.style.display = 'none';
            dom.pauseIcon.style.display = 'block';
            dom.playPauseBtn.setAttribute('aria-label', 'Pausar');
        } else {
            dom.playIcon.style.display = 'block';
            dom.pauseIcon.style.display = 'none';
            dom.playPauseBtn.setAttribute('aria-label', 'Tocar');
        }

        // Informações da faixa
        const currentTrack = state.playlist[state.currentIndex];
        if (currentTrack) {
            dom.trackTitleEl.textContent = currentTrack.title;
            dom.trackArtistEl.textContent = currentTrack.artist;
            if(currentTrack.picture) {
                dom.albumArtImg.src = currentTrack.picture;
                dom.albumArtImg.style.display = 'block';
                dom.albumArtPlaceholder.style.display = 'none';
            } else {
                 dom.albumArtImg.style.display = 'none';
                 dom.albumArtPlaceholder.style.display = 'flex';
            }
            document.title = `${currentTrack.title} - ${currentTrack.artist}`;
        } else {
            dom.trackTitleEl.textContent = 'Nenhuma música tocando';
            dom.trackArtistEl.textContent = 'Adicione músicas para começar';
            dom.albumArtImg.src = '';
            dom.albumArtImg.style.display = 'none';
            dom.albumArtPlaceholder.style.display = 'flex';
            document.title = 'Player de Música Offline';
        }

        // Destaque na Playlist
        const playlistItems = dom.playlistEl.querySelectorAll('.playlist-item');
        playlistItems.forEach((item, index) => {
            item.classList.toggle('playing', index === state.currentIndex);
        });
    }

    function updateVolumeIcon() {
        if(dom.audioPlayer.muted || dom.audioPlayer.volume === 0) {
            dom.volumeHighIcon.style.display = 'none';
            dom.volumeMuteIcon.style.display = 'block';
        } else {
            dom.volumeHighIcon.style.display = 'block';
            dom.volumeMuteIcon.style.display = 'none';
        }
    }
    
    function updateLoopIcon() {
        dom.loopBtn.classList.toggle('active', state.loopMode !== 'none');
        dom.loopAllIcon.style.display = state.loopMode !== 'one' ? 'block' : 'none';
        dom.loopOneIcon.style.display = state.loopMode === 'one' ? 'block' : 'none';
    }

    // --- Helpers ---
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function showToast(message) {
        dom.toast.textContent = message;
        dom.toast.classList.add('show');
        setTimeout(() => {
            dom.toast.classList.remove('show');
        }, 3000);
    }

    // --- Lógica de Drag and Drop (Arquivos e Playlist) ---
    function handleDragStart(e) {
        state.draggedItem = this;
        setTimeout(() => this.classList.add('ghost'), 0);
    }
    
    function handleDragEnd() {
        this.classList.remove('ghost');
        state.draggedItem = null;
        dom.playlistEl.querySelectorAll('.playlist-item').forEach(item => item.classList.remove('over'));
    }

    function handleDragOver(e) {
        e.preventDefault();
        this.classList.add('over');
    }
    
    function handleDragLeave() {
         this.classList.remove('over');
    }

    function handleDrop(e) {
        e.preventDefault();
        if (state.draggedItem !== this) {
            const fromIndex = parseInt(state.draggedItem.dataset.index, 10);
            const toIndex = parseInt(this.dataset.index, 10);
            
            // Reordenar o array
            const [movedItem] = state.playlist.splice(fromIndex, 1);
            state.playlist.splice(toIndex, 0, movedItem);

            // Atualizar o currentIndex se a faixa atual foi movida
            if (state.currentIndex === fromIndex) {
                state.currentIndex = toIndex;
            } else if (state.currentIndex > fromIndex && state.currentIndex <= toIndex) {
                state.currentIndex--;
            } else if (state.currentIndex < fromIndex && state.currentIndex >= toIndex) {
                state.currentIndex++;
            }
            renderPlaylist();
        }
    }

    // --- Event Listeners ---
    dom.playPauseBtn.addEventListener('click', togglePlayPause);
    dom.nextBtn.addEventListener('click', playNext);
    dom.prevBtn.addEventListener('click', playPrev);
    dom.audioPlayer.addEventListener('timeupdate', updateProgress);
    dom.audioPlayer.addEventListener('ended', handleTrackEnd);
    dom.audioPlayer.addEventListener('loadedmetadata', () => {
        dom.totalDurationEl.textContent = formatTime(dom.audioPlayer.duration);
        // Atualiza a duração na playlist se ainda não estiver definida
        const track = state.playlist[state.currentIndex];
        if (track && !track.duration) {
            track.duration = dom.audioPlayer.duration;
            renderPlaylist();
        }
    });

    dom.progressBar.addEventListener('input', (e) => {
        const { duration } = dom.audioPlayer;
        if(duration) {
            const seekTime = (e.target.value / 100) * duration;
            dom.currentTimeEl.textContent = formatTime(seekTime);
        }
    });
    dom.progressBar.addEventListener('change', seek);
    dom.progressBar.addEventListener('mousedown', () => state.isSeeking = true);
    dom.progressBar.addEventListener('mouseup', () => state.isSeeking = false);

    dom.volumeSlider.addEventListener('input', setVolume);
    dom.muteBtn.addEventListener('click', toggleMute);
    dom.loopBtn.addEventListener('click', toggleLoop);
    dom.shuffleBtn.addEventListener('click', toggleShuffle);
    
    dom.addMusicBtn.addEventListener('click', () => dom.fileInput.click());
    dom.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    dom.clearLibraryBtn.addEventListener('click', clearLibrary);

    // Drag and Drop de arquivos
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, e => {
            e.preventDefault();
            e.stopPropagation();
        });
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        document.body.addEventListener(eventName, () => dom.dragOverlay.classList.add('visible'));
    });
    ['dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, () => dom.dragOverlay.classList.remove('visible'));
    });
    document.body.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));
    
    // Atalhos de teclado
    window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return; // Ignora atalhos em inputs
        switch(e.code) {
            case 'Space':
                e.preventDefault();
                togglePlayPause();
                break;
            case 'ArrowRight':
                e.preventDefault();
                dom.audioPlayer.currentTime += 5;
                break;
            case 'ArrowLeft':
                e.preventDefault();
                dom.audioPlayer.currentTime -= 5;
                break;
            case 'ArrowUp':
                e.preventDefault();
                dom.volumeSlider.value = Math.min(1, parseFloat(dom.volumeSlider.value) + 0.05);
                setVolume();
                break;
            case 'ArrowDown':
                e.preventDefault();
                dom.volumeSlider.value = Math.max(0, parseFloat(dom.volumeSlider.value) - 0.05);
                setVolume();
                break;
            case 'KeyN':
                 e.preventDefault();
                 playNext();
                 break;
            case 'KeyP':
                 e.preventDefault();
                 playPrev();
                 break;
        }
    });

    // --- Inicialização ---
    async function initialize() {
        try {
            await initDB();
            const tracks = await getAllTracksFromDB();
            state.playlist = tracks;
            renderPlaylist();
            updateUI();
        } catch(error) {
            console.error("Falha na inicialização:", error);
            showToast("Não foi possível carregar sua biblioteca.");
        }
    }
    
    // --- Service Worker (para caching offline do app shell) ---
    if ('serviceWorker' in navigator) {
        // Usamos um truque para criar o SW a partir de um Blob, já que estamos em um único arquivo.
        // Nota: isso pode ter limitações de segurança em alguns navegadores quando aberto via file://
        const swContent = `
            const CACHE_NAME = 'offline-music-player-cache-v1';
            const urlsToCache = ['.']; // Cache o próprio arquivo HTML
            
            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => {
                            console.log('Opened cache');
                            return cache.addAll(urlsToCache);
                        })
                );
            });
            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            return response || fetch(event.request);
                        }
                    )
                );
            });
        `;
        const blob = new Blob([swContent], {type: 'application/javascript'});
        navigator.serviceWorker.register(URL.createObjectURL(blob))
        .then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }).catch(error => {
            console.log('ServiceWorker registration failed: ', error);
        });
    }

    initialize();
});
</script>
</body>
</html>

